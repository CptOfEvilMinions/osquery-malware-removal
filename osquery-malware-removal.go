package main

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"flag"
	"io"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"time"

	"github.com/kolide/osquery-go"
	"github.com/kolide/osquery-go/plugin/table"
	"github.com/shirou/gopsutil/process"
)

// main input: Takes in user input where the Osquery socket is located
// This function registers this Osquery extension using the user provided socket path
// main output: None
func main() {
	// Extract command line arguments
	flSocketPath := flag.String("socket", "", "path to osqueryd extensions socket")
	flTimeout := flag.Int("timeout", 0, "")
	flag.Int("interval", 0, "")
	flag.Parse()

	// allow for osqueryd to create the socket path
	timeout := time.Duration(*flTimeout) * time.Second
	time.Sleep(2 * time.Second)

	// initializing server objecet
	server, err := osquery.NewExtensionManagerServer("malware_removal", *flSocketPath, osquery.ServerTimeout(timeout))

	// If initializing server fails exit
	if err != nil {
		log.Fatalf("Error creating extension: %s\n", err)
	}

	// Create and register a new table plugin with the server.
	// table.NewPlugin requires the table plugin name,
	// a slice of Columns and a generate function.
	// If server.Run() fails exit
	server.RegisterPlugin(table.NewPlugin("malware_removal", MalwareRemovalColumns(), MalwareRemovalGenerate))
	if err := server.Run(); err != nil {
		log.Fatalln(err)
	}

}

// MalwareRemovalColumns input: None
// MalwareRemovalColumns output: returns the columns that our table will return.
func MalwareRemovalColumns() []table.ColumnDefinition {
	return []table.ColumnDefinition{
		table.TextColumn("file_path"),
		table.TextColumn("dir_path"),
		table.TextColumn("file_hash"),
		table.TextColumn("pid"),
		table.TextColumn("status"),
		table.TextColumn("status_bool"),
	}
}

// MalwareRemovalGenerate input: ctx and query context
// MalwareRemovalGenerate output: Returns a map which contains all the values passed into
func MalwareRemovalGenerate(ctx context.Context, queryContext table.QueryContext) ([]map[string]string, error) {
	var filePath string
	var dirPath string
	var fileHash string
	var processID string
	var status string
	var statusBool bool

	if len(queryContext.Constraints["pid"].Constraints) == 1 {
		processID = queryContext.Constraints["pid"].Constraints[0].Expression
		statusBool, status = terminateProcess(processID)
	} else if len(queryContext.Constraints["file_path"].Constraints) == 1 {
		filePath = queryContext.Constraints["file_path"].Constraints[0].Expression
		statusBool, status = deleteFile(filePath)
	} else if len(queryContext.Constraints["dir_path"].Constraints) == 1 && len(queryContext.Constraints["file_hash"].Constraints) == 0 {
		dirPath = queryContext.Constraints["dir_path"].Constraints[0].Expression
		statusBool, status = deleteDirectory(dirPath)
	} else if len(queryContext.Constraints["dir_path"].Constraints) == 1 && len(queryContext.Constraints["file_hash"].Constraints) == 1 {
		dirPath = queryContext.Constraints["dir_path"].Constraints[0].Expression
		fileHash = queryContext.Constraints["file_hash"].Constraints[0].Expression
		statusBool, status = deleteFileHash(fileHash, dirPath)
	} else {
		status = "Please specify file_path, dir_path, file_hash, or pid"
	}

	return []map[string]string{
		{
			"status":      status,
			"status_bool": strconv.FormatBool(statusBool),
			"pid":         processID,
			"file_path":   filePath,
			"dir_path":    dirPath,
			"file_hash":   fileHash,
		},
	}, nil

}

// deleteFile input: filepath of file to be deleted
// deleteFile output: Return a boolean of operation and string about operation result
// If the function fails it will return false and the error
func deleteFile(filePath string) (bool, string) {
	// Detect if file exists
	_, err := os.Stat(filePath)
	if os.IsNotExist(err) {
		return false, "File does not exist"
	}

	// Delete file
	err = os.Remove(filePath)
	if err == nil {
		return true, "Sucess"
	}
	return false, err.Error()

}

// deleteDirectory input: directoryPath of directory to be deleted
// deleteDirectory output: Return a boolean of operation and string about operation result
// If the function fails it will return false and the error
func deleteDirectory(directoryPath string) (bool, string) {
	// Detect if directory exists
	_, err := os.Stat(directoryPath)
	if os.IsNotExist(err) {
		return false, "File does not exist"
	}

	// Delete file
	err = os.RemoveAll(directoryPath)
	if err == nil {
		return true, "Sucess"
	}
	return false, err.Error()
}

// terminateProcess input: process ID to be terminated
// terminateProcess output: Return a boolean of operation and string about operation result
// If the function fails it will return false and the error
func terminateProcess(pid string) (bool, string) {
	// Convert string  to int
	tempProcessID, tempErr := strconv.Atoi(pid)
	if tempErr != nil {
		return false, "Couldn't cconvert string to int"
	}

	// Init process object with PID
	p, err := process.NewProcess(int32(tempProcessID))
	if err != nil {
		return false, err.Error()
	}

	// Kill the parent process
	err = p.Kill()
	if err == nil {
		return true, "success"
	}

	return false, err.Error()
}

// deleteFileHash input: fileHash to delete and directory where the file is located
// deleteFileHash output: Return a boolean of operation and string about operation result
// If the function fails it will return false and the error
func deleteFileHash(fileHash string, directoryPath string) (bool, string) {
	// Get all files in directory
	files, err := ioutil.ReadDir(directoryPath)
	if err != nil {
		return false, err.Error()
	}

	// Iterate through all files in directory
	for _, f := range files {
		// Skip item if it is a directory
		if f.IsDir() {
			continue
		}

		// Create full file path
		absoluteFilePath := directoryPath + "/" + f.Name()

		// Calculate SHA256 file hash
		tempFileHashBool, tempFileHash := calculateSHA256File(absoluteFilePath)

		// Attempt to delete file
		if tempFileHash == fileHash && tempFileHashBool == true {
			statusBool, status := deleteFile(absoluteFilePath)
			if statusBool == true {
				return true, status
			}
		}
	}

	// Default return of false
	return false, "Hash not found"
}

// calculateSHA256File input: file path
// calculateSHA256File output: calculated SHA256 file hash
// If the function fails it will return false and the error
func calculateSHA256File(filepath string) (bool, string) {
	// OPen file
	f, err := os.Open(filepath)
	if err != nil {
		return false, err.Error()
	}
	defer f.Close()

	h := sha256.New()
	if _, err := io.Copy(h, f); err != nil {
		return false, err.Error()
	}

	return true, hex.EncodeToString(h.Sum(nil))
}
